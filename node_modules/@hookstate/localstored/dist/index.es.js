function localstored(options) {
    return function () {
        var key;
        var serializer;
        var deserializer;
        var stateAtRoot;
        var storageEngine = (options === null || options === void 0 ? void 0 : options.engine) || localStorage;
        return {
            onInit: function (state, extensionMethods) {
                stateAtRoot = state;
                if ((options === null || options === void 0 ? void 0 : options.key) === undefined) {
                    if (extensionMethods['identifier'] === undefined) {
                        throw Error('State is missing Identifiable extension');
                    }
                    key = extensionMethods['identifier'](state);
                }
                else {
                    key = options.key;
                }
                if (extensionMethods['serialize'] !== undefined) {
                    serializer = extensionMethods['serialize'];
                }
                else {
                    serializer = function (s) { return function () { return JSON.stringify(s.get({ noproxy: true })); }; };
                }
                if (extensionMethods['deserialize'] !== undefined) {
                    deserializer = extensionMethods['deserialize'](state);
                }
                else {
                    deserializer = function (s) { return function (v) { return s.set(JSON.parse(v)); }; };
                }
                // here it is synchronous, but most storages would be async
                // this is supported too, as the state.set can be really set asynchronously
                var response = storageEngine.getItem(key);
                Promise.resolve(response).then(function (persisted) {
                    if (persisted) {
                        // persisted state exists
                        deserializer(state)(persisted); // this one sets the state value as well
                    }
                    else if (options === null || options === void 0 ? void 0 : options.initializer) {
                        options.initializer().then(function (s) {
                            state.set(s);
                        });
                    }
                });
            },
            onSet: function (s) {
                if (s.promised || s.error !== undefined) {
                    var response = storageEngine.removeItem(key);
                    Promise.resolve(response).then(function () { });
                }
                else {
                    // save the entire state from the root
                    // smarter implementations could implement partial state saving,
                    // which would save only the nested state set (parameter `s` in onSet)
                    var response = storageEngine.setItem(key, serializer(stateAtRoot)());
                    Promise.resolve(response).then(function () { });
                }
            }
        };
    };
}

export { localstored };
//# sourceMappingURL=index.es.js.map
